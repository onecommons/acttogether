misc = require('utils');
pyPop = misc.pyPop;
var mongodb = require('mongodb');
var DBRef = mongodb.DBRef, ObjectID = mongodb.ObjectID;

var pJSON = {
  //XXX escape $ with U+FF04  and . with U+FF0E  http://docs.mongodb.org/manual/faq/developers/#how-does-mongodb-address-sql-or-query-injection
  stringify: function(value, space) {
    /*
      ObjectIds are serialized as @@id
      '_id' key as @value
      string values starting @ or :: are prepended with ::
      DBRefs are serialized as @collection$id
    */
    return JSON.stringify(value, function(k,v) {
      if (v && typeof v === 'object') {
        //we have to do it like this to avoid toString being call internally
        var copy = new v.constructor();
        for (var prop in v) { 
          if (!v.hasOwnProperty(prop)) continue;
          var val = v[prop]
          if (val instanceof ObjectID) {
              val = "@@" + val;
          } else if (val instanceof DBRef) {
             val = '@' + val.namespace + '$' + val.oid;
          } else if (prop == '_id') { //user defined ids
            //assert typeof v  String and !v.charAt(0) == '@'/ /XXX
            val = '@' + val;
          } else if (typeof val == 'string' && (val.charAt(0) == '@' || val.slice(0,2) == '::')) {
             val = '::' + val;
          }
          copy[prop] = val;
        }
        return copy;
      }
      return v;
    }, space);
  },
  parse: function(text) {
    return JSON.parse(text, this.reviver);
  },
  reviver: function(k,v){
      /*
      string values starting with @@ are treated as objectids
      string values starting with @*$* are converted to DbRefs 
      string values starting with @ are treated as user-defined id references in the current collection
      strings strip leading ::
      */
      if (typeof v == 'string') { 
        var prefix = v.slice(0,2);
        if (prefix =='@@') {
          return ObjectID(v.slice(2));
        } else if (prefix == '::'){
          return v.slice(2);
        } else {
          if (prefix.charAt(0) == '@') {
            var index = v.indexOf('$');
            if (index > -1) {
              return new DBRef(v.slice(1, index), ObjectID(v.slice(index+1)));
            } else {
              if (k == '_id')
                return v.slice(1);
              else
                return v; //new DBRef(currentCollectionnamespace, v.slice(1));
            }
          }
        }
      }
    return v;
  }  
}

var Datastore = function(collection) {
   this.collection = collection;
};

Datastore.prototype = {
  defaultOptions: {w: 1}

  ,_getmjson: function(mjson) {
    if (typeof mjson == 'string') 
      mjson = pJSON.parse(mjson);
    if (typeof mjson != 'object' || Array.isArray(mjson))
      throw new Error("invalid pjson object");
    return mjson;
  }
  
  //add the specified keys
  //if the key exists error if its current value is not an array
  //key doesn't exist its added with the value as first entry in an array
  //if value is an array, the values are appended to current array XXX need override
  //error if not _id or _id doesn't exist
  ,add: function(mjson, cb) {
    mjson = this._getmjson(mjson);

    var obj = {};
    /* XXX
    if (!mjson._id) {
       cb(err)
    } */
    for (var key in mjson) {
        if (!mjson.hasOwnProperty(key) || key == '_id') continue;
        var val = mjson[key];
        if (Array.isArray(val))
          obj[key] = {$each: val};
        else
          obj[key] = val;
    }
    this.collection.update({_id:mjson._id},{$addToSet: obj}, this.defaultOptions, cb);
  }
  
  //remove the specified values or keys
  //if the value is null, the key is removed
  //if the key has a value it is assumed the key is an array and only that value is being removed from the array
  //if value is an array each item is removed
  //if value or key doesn't exists ????????
  //error if not _id or _id doesn't exist
  ,remove: function(mjson, cb) {
    //$pull or $unset
    mjson = this._getmjson(mjson);

    var unset = {}, pull = {}, pullAll = {};
    for (var key in mjson) {
        if (!mjson.hasOwnProperty(key)) continue;
        var val = mjson[key];
        if (val === null) {
          unset[key] = '';
        }
        if (Array.isArray(val))
          pullAll[key] = val;
        else
          pull[key] = val;
    }
    var updateObj = {
      $unset: unset,
      $pull: pull,
      $pullAll: pullAll
    };
    this.collection.update({_id:_id}, updateObj,this.defaultOptions,cb);
  } 
  
  /*
  replaces the current object 
  if _id doesn't exist, error //creates new object
  error if no _id
  */
  ,replace: function(mjson, cb) {
    mjson = this._getmjson(mjson);
    this.collection.save(mjson, this.defaultOptions, cb);
  }

  ,_update:  function(mjson) {
    if (typeof mjson != 'object' || Array.isArray(mjson))
        throw new Error("invalid pjson object");
      mjson = misc.merge({}, mjson) //copy so we don't mutate original arg
      var options = this.defaultOptions; //misc.merge({upsert:true}, this.defaultOptions);
      var _id = pyPop(mjson, '_id');
      this.collection.update({_id:_id}, {$set: mjson}, options, cb);
  }

  /*
  replaces specified fields
  if _id doesn't exist, error //creates new object
  error if no _id
  */
  ,update: function(mjson, cb) {
    if (typeof mjson == 'string')
      mjson = pJSON.parse(mjson);

    if (Array.isArray(mjson))
      mjson.each(_update.bind(this)); 
    else
      this._update(mjson);
  }

  /*
  creates a new obj, returns new id
  error if id is specified and already exists
  */
  ,create: function(mjson, cb) {
    mjson = this._getmjson(mjson);
    //create the given object, error if _id exists
    this.collection.insert(mjson, this.defaultOptions, cb);
  } 
  ,query: function(mjson, cb) {
    mjson = this._getmjson(mjson);
    //json.criteria, json.projection
    this.collection.find().toArray(cb);
  }
};

var RequestHandler = function(collection) {
   this.collection = collection;
};


RequestHandler.prototype = Object.create(Datastore.prototype);
RequestHandler.prototype.constructor = RequestHandler;

var DatastoreBase = Datastore.prototype;

RequestHandler.prototype._getJsonrpcResponse = function(err, doc, op) {
    if (err) {
      return {error: 
        { code: -32001,
          message: "Data Error",
          data: err
        }
      };
    } else {
      return {result: doc};
    }
}

RequestHandler.prototype.add = function(mjson, respond) {
    var This = this;
    DatastoreBase.add.call(this, mjson, function(err, doc){
      //doc is array of records inserted
      respond(This._getJsonrpcResponse(err, doc));
    });
}

RequestHandler.prototype.remove = function(mjson, respond) {
    var This = this;
    DatastoreBase.remove.call(this, mjson, function(err, doc){
      //doc is array of records inserted
      respond(This._getJsonrpcResponse(err, doc));
    });
} 

RequestHandler.prototype.replace = function(mjson, respond) {
    var This = this;
    DatastoreBase.replace.call(this, mjson, function(err, doc){
      //doc is array of records inserted
      respond(This._getJsonrpcResponse(err, doc));
    });
}

RequestHandler.prototype.update = function(mjson, respond) {
    var This = this;
    DatastoreBase.update.call(this, mjson, function(err, doc){
      //doc is array of records inserted
      respond(This._getJsonrpcResponse(err, doc));
    });
}
  
RequestHandler.prototype.create = function(mjson, respond) {
    var This = this;
    DatastoreBase.create.call(this, mjson, function(err, doc){
      //doc is array of records inserted
      respond(This._getJsonrpcResponse(err, doc));
    });
}

RequestHandler.prototype.query = function(mjson, respond) {
    var This = this;
    DatastoreBase.query.call(this, mjson, function(err, doc){
      respond(This._getJsonrpcResponse(err, doc));
    });
} 

RequestHandler.prototype.transaction_info = function(json, respond) {
    var This = this, doc = {};
    //XXX
    //if (json.comment)
    //  document.comment = Template(comment).safe_substitute(newresourcesCreated);
    respond(This._getJsonrpcResponse(null, doc));
}

exports.pJSON = pJSON;
exports.Datastore = Datastore;
exports.RequestHandler = RequestHandler;