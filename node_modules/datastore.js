misc = require('utils');
pyPop = misc.pyPop;
var mongodb = require('mongodb');
var DBRef = mongodb.DBRef, ObjectID = mongodb.ObjectID;

var pJSON = {
  stringify: function(value, space) {
    /*
      ObjectIds are serialized as @@id
      '_id' key as @value
      string values starting @ or :: are prepended with ::
      DBRefs are serialized as @collection$id
    */
    return JSON.stringify(value, function(k,v) {
      if (v && typeof v === 'object') {
        //we have to do it like this to avoid toString being call internally
        var copy = new v.constructor();
        for (var prop in v) { 
          if (!v.hasOwnProperty(prop)) continue;
          var val = v[prop]
          if (val instanceof ObjectID) {
              val = "@@" + val;
          } else if (val instanceof DBRef) {
             val = '@' + val.namespace + '$' + val.oid;
          } else if (prop == '_id') { //user defined ids
            //assert typeof v  String and !v.charAt(0) == '@'/ /XXX
            val = '@' + val;
          } else if (typeof val == 'string' && (val.charAt(0) == '@' || val.slice(0,2) == '::')) {
             val = '::' + val;
          }
          copy[prop] = val;
        }
        return copy;
      }
      return v;
    }, space);
  },
  parse: function(text) {
    return JSON.parse(text, this.reviver);
  },
  reviver: function(k,v){
      /*
      string values starting with @@ are treated as objectids
      string values starting with @*$* are converted to DbRefs 
      string values starting with @ are treated as user-defined id references in the current collection
      strings strip leading ::
      */
      if (typeof v == 'string') { 
        var prefix = v.slice(0,2);
        if (prefix =='@@') {
          return ObjectID(v.slice(2));
        } else if (prefix == '::'){
          return v.slice(2);
        } else {
          if (prefix.charAt(0) == '@') {
            var index = v.indexOf('$');
            if (index > -1) {
              return new DBRef(v.slice(1, index), ObjectID(v.slice(index+1)));
            }
          }
        }
      }
    return v;
  }  
}

var Datastore = function(collection) {
   this.collection = collection;
};

Datastore.prototype = {
  add: function(mjson, cb) {
    /*
    $addToSet with $each (error if value is not an array)
    */
    if (typeof mjson == 'string') mjson = pJSON.parse(mjson);
    var obj = {};
    for (var key in mjson) {
        if (!mjson.hasOwnProperty(key)) continue;
        var val = mjson[key];
        if (Array.isArray(val))
          obj[key] = {$each: val};
        else
          obj[key] = val;
    }
    this.collection.update({_id:_id},{$addToSet: obj},{safe:true}, cb);
  }
  ,remove: function(mjson, cb) {
    //$pull or $unset
    if (typeof mjson == 'string') mjson = pJSON.parse(mjson);
    var unset = {}, pull = {}, pullAll = {};
    for (var key in mjson) {
        if (!mjson.hasOwnProperty(key)) continue;      
        var val = mjson[key];
        if (val === null) {
          unset[key] = '';
        }
        if (Array.isArray(val))
          pullAll[key] = val;
        else
          pull[key] = val;
    }
    var updateObj = {
      $unset: unset,
      $pull: pull,
      $pullAll: pullAll
    };
    this.collection.update({_id:_id}, updateObj,{safe:true},cb);
  } 
  ,replace: function(mjson, cb) {
    if (typeof mjson == 'string') mjson = pJSON.parse(mjson);
    this.collection.save(mjson, {safe:true}, cb);
    //$pull or $unset
  } 
  ,update: function(mjson, cb) {
    if (typeof mjson == 'string') mjson = pJSON.parse(mjson);
    if (!mjson._id) {
      return create(mjson, res);
    }
    var _id = pyPop(mjson, '_id');
    this.collection.update({_id:_id}, {$set: mjson}, {safe:true}, cb);
  }
  ,create: function(mjson, cb) {
    if (typeof mjson == 'string') mjson = pJSON.parse(mjson);
    //create the given object, error if _id exists
    this.collection.insert(mjson, {safe:true}, cb);
  } 
  ,query: function(mjson, cb) {
    if (typeof mjson == 'string') mjson = pJSON.parse(mjson);
    //json.criteria, json.projection
    this.collection.find().toArray(cb);
  } 
};

var RequestHandler = function(collection) {
   this.collection = collection;
};

var DatastoreBase = Datastore.prototype;
RequestHandler.prototype = {
  add: function(mjson, respond) {
    DatastoreBase.add.call(this, mjson, function(err, doc){
      //doc is array of records inserted
      respond({result:'ok'})
    });
  }
  ,remove: function(mjson, respond) {
    DatastoreBase.remove.call(this, mjson, function(err, doc){
      //doc is array of records inserted
      respond({result:'ok'})
    });
  } 
  ,replace: function(mjson, respond) {
    DatastoreBase.replace.call(this, mjson, function(err, doc){
      //doc is array of records inserted
      respond({result:'ok'})
    });
  } 
  ,update: function(mjson, respond) {
    DatastoreBase.update.call(this, mjson, function(err, doc){
      //doc is array of records inserted
      respond({result:'ok'})
    });
  }
  ,create: function(mjson, respond) {
    DatastoreBase.create.call(this, mjson, function(err, doc){
      //doc is array of records inserted
      respond({result:'ok'})
    });
  } 
  ,query: function(mjson, respond) {
    DatastoreBase.query.call(this, mjson, function(err, doc){
      //doc is array of records inserted
      respond({result:doc})
    });
  } 
  ,transaction_info: function(json, respond) {
    respond({result:'ok'});
  }   
}

exports.pJSON = pJSON;
exports.Datastore = Datastore;
exports.RequestHandler = RequestHandler;